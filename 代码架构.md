## core

### scripts@core/old_base.js:

```js
import {Airplane, Sky, Sea} from '../scripts@core/customObject.js';
//SCENE & CAMERA VARIABLES
var scene = null,
    camera = null,
    renderer = null;

// 3D Models in customObjects.js
var sea = null, // createdBy new Sea()
    airplane = null, // createdBy new AirPlane()
    sky = null; // createdBy new Sky()

window.onload = ↓
function createScene() {}
function createLights() {}
function createObjects() { createPlane() && createSea() && createSky() }

```

```js

class WhenPaused { // 直接通过WhenPaused访问，class
  static start () { } // WhenPaused.start() 执行暂停时的渲染流程
  static backTo (newRenderLoop) { } // WhenPaused.backTo(renderLoop) 回到原来的渲染流程
}

waitForUserContinue() {
  // 返回promise
  // 当用户继续时fulfill
  // 当用户离开/重新开始时reject
}

```

```js

class Score {
  constructor (domElement, initialSpeed, initialScore = this.loadPrevious()) {

  } // domElement：score写入内容的HTMLElement，initialSpeed：初始速度，initialScore：可选。
  start () { } // 开始记录成绩并写入domElement
  pause () { } // 暂停记录成绩，并暂停写入domElement
  store () { } // 将成绩加密后存储，以便下次使用。无返回值。
  loadPrevious () { } // 加载上一次存储的成绩，返回整型成绩
  get value () {
    return this.updateValue();
  } // 更新score后返回最新成绩，浮点。
}

```

```typescript

new ThrottleLog(gap: number) // 新建一个ThrottleLog对象，每隔gap时间console.log相应值一次

ThrottleLog.log(whatever: any) // 至少每隔gap时间console.log相应值一次（需外界调用）

ThrottleLog.autoLog(whatever: any) // 自动每隔gap时间console.log相应值一次

ThrottleLog.stopAutoLog() // 停止autoLog

```

### scripts@core/ui.js

```js

class UserInteraction {
  get isTouchDevice () {
    return this.#isTouchDevice; // 是否是触摸屏设备
  }

  get relativePos () {
    // 鼠标的相对位置，-1 - 1
  }

  get HEIGHT () {
    return this.#windowHeight; // 屏幕高度
  }

  get WIDTH () {
    return this.#windowWidth; // 屏幕宽度
  }

  addListeners () {
    // 监听用户操作
  }

  removeListeners () {
    // 停止监听用户操作
  }

  addResizeCallback (func) {
    // 添加新的在resize时执行的函数
  }

  listenResize () {
    // 监听页面宽高改变（如缩放、更改页面朝向等），更新HEIGHT、WIDTH等
    // 当用户改变视窗大小时执行addResizeCallback添加的相关内容
  }

  canvas2D.paint() {
    // 绘制2D动态用户交互
  }
}

```

## config

### scripts@config/config.js

```typescript
interface config {
  testMode: boolean,
  version: string,
  cameraSetting: object,
  getContainer: function,
  gameStartCallback: function,
  speed_sea: number,
  speed_sky: number
  useNewBasejs: boolean,
  defaultPropellerSpeed: number,
  numOfCloudsInSky: number,
  colors: {
      red: 0xf25346,
      white: 0xd8d0d1,
      brown: 0x59332e,
      pink: 0xF5986E,
      brownDark: 0x23190f,
      blue: 0x68c3c0,
    }
}
 // 直接设置为window.config，而非module
```

```js

window.setCookie(value, expireDays)
  /**
   * 设置cookie
   * @param {string} value no semicolon
   * @param {number} expireDays
   * @return {undefined} 
   */
window.existsCookie(value)
  /**
   * 检查cookie是否存在
   * @param {string} name
   * @return {boolean} 
   */
```

```typescript

Dialog.newError(args: any) // throw an error to user

Dialog.newConfirm(title: string, paragraphs: string | Array<string>, confirmText: string, rejectText: string)
  /**
   * display a self defined confirm dialog other than browser's default
   * @param {string} title 
   * @param {string | Array<string>} paragraphs
   * @param {string} confirmText
   * @param {string} rejectText
   * @return {Promise<boolean>} 
   */
```

## scripts@miscellaneous

### serviceWorker.js

其作用为缓存各个脚本文件、页面文件等，以加快页面加载、减少带宽占用，及实现离线访问。

当一个serviceWorker被注册成功后，它会一直存在（不会随着的页面的关闭而死亡，只会被暂停），其注册成功之后会缓存任何当前网页请求的任何内容，以便离线浏览。（未来我们将利用此特性部署windows应用和app）

通过设置其noCache = true可将其缓存功能关闭（方便调试时的实时更新）。默认为关闭状态。

**注意：当noCache = true时，页面仍会缓存index.html与three.min.js**

cacheResources数组是serviceWorker第一次注册时主动缓存的文件（即重要的、之后大概率会使用的文件）

DLC数组存储第一次注册时可选缓存的文件。当用户打开流量保护时serviceWorker不会主动缓存DLC数组中的内容。

可F12 -> Application(console element那一栏的右侧) -> Cache - Cache storage处查看被缓存的库（可删除之来手动更新到最新版本）

可F12 -> Application(console element那一栏的右侧) -> Application - service worker处删除、更新service worker。

使用<kbd>ctrl</kbd> + <kbd>F5</kbd>可强制刷新当前页面，不会经过service worker，service worker也不会缓存强制刷新后的界面。

因为安全问题，serviceWorker.js只能放于根目录（即与index.html同一目录）

### scripts@miscellaneous/audioWorker.js

音乐存储在indexedDB。可F12 -> Application(console element那一栏的右侧) -> Storage - IndexedDB处查看被存储起的音乐文件。

```js
audioPlayer.preloadLength = 2 // 在当前播放的音乐前预先加载的音乐数量
audioPlayer.songs = {
  nextsToPlay: new Array(this.preloadLength), // 接下来等待播放的音乐
  currentIndex: 0, // 当前播放在sequenceArr中的index
  shuffle: false // 是否随机播放
};
audioPlayer.sequenceArr = []; // 音乐的顺序列表
audioPlayer.songPlaying.name // 当前播放音乐的名称 

audioPlayer.volume // 更改|获取音量
audioPlayer.pause() // 暂停
audioPlayer.resume() // 继续从暂停的位置播放
audioPlayer.stop(delay = 0) // 停止当前音乐的播放，并从内存中清除
async function playNext (autoPlay = false) 
 /**
   * 播放按顺序的下一首歌
   * 注意，当autoPlay为true时，playNext会不断递归执行
   * 即playNext(true).then中的语句永远不会被执行。
   * audioPlayer.stop()可终止其自动顺序循环播放。终止后playNext(true)返回reject的promise
   * @param {undefined | boolean} autoPlay 默认false。若为true，则自动顺序循环播放
   * @return {Promise} 
   */
async function playSong (param, loop = false) 
  /**
   * 播放歌曲。
   * @param {string | Object} param 要播放歌曲的role或包含其信息的对象
   * @param {boolean} loop 是否循环
   */
```