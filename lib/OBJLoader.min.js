import * as THREE from 'https://cdn.jsdelivr.net/npm/three@v0.121.0/build/three.module.min.js';
let object_pattern=/^[og]\s*(.+)?/,material_library_pattern=/^mtllib /,material_use_pattern=/^usemtl /,map_use_pattern=/^usemap /,vA=new THREE.Vector3,vB=new THREE.Vector3,vC=new THREE.Vector3,ab=new THREE.Vector3,cb=new THREE.Vector3;function ParserState(){var e={objects:[],object:{},vertices:[],normals:[],colors:[],uvs:[],materials:{},materialLibraries:[],startObject:function(e,t){if(this.object&&!1===this.object.fromDeclaration)return this.object.name=e,void(this.object.fromDeclaration=!1!==t);var r=this.object&&"function"==typeof this.object.currentMaterial?this.object.currentMaterial():void 0;if(this.object&&"function"==typeof this.object._finalize&&this.object._finalize(!0),this.object={name:e||"",fromDeclaration:!1!==t,geometry:{vertices:[],normals:[],colors:[],uvs:[],hasNormalIndices:!1,hasUVIndices:!1},materials:[],smooth:!0,startMaterial:function(e,t){var r=this._finalize(!1);r&&(r.inherited||r.groupCount<=0)&&this.materials.splice(r.index,1);var s={index:this.materials.length,name:e||"",mtllib:Array.isArray(t)&&t.length>0?t[t.length-1]:"",smooth:void 0!==r?r.smooth:this.smooth,groupStart:void 0!==r?r.groupEnd:0,groupEnd:-1,groupCount:-1,inherited:!1,clone:function(e){var t={index:"number"==typeof e?e:this.index,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0,groupEnd:-1,groupCount:-1,inherited:!1};return t.clone=this.clone.bind(t),t}};return this.materials.push(s),s},currentMaterial:function(){if(this.materials.length>0)return this.materials[this.materials.length-1]},_finalize:function(e){var t=this.currentMaterial();if(t&&-1===t.groupEnd&&(t.groupEnd=this.geometry.vertices.length/3,t.groupCount=t.groupEnd-t.groupStart,t.inherited=!1),e&&this.materials.length>1)for(var r=this.materials.length-1;r>=0;r--)this.materials[r].groupCount<=0&&this.materials.splice(r,1);return e&&0===this.materials.length&&this.materials.push({name:"",smooth:this.smooth}),t}},r&&r.name&&"function"==typeof r.clone){var s=r.clone(0);s.inherited=!0,this.object.materials.push(s)}this.objects.push(this.object)},finalize:function(){this.object&&"function"==typeof this.object._finalize&&this.object._finalize(!0)},parseVertexIndex:function(e,t){var r=parseInt(e,10);return 3*(r>=0?r-1:r+t/3)},parseNormalIndex:function(e,t){var r=parseInt(e,10);return 3*(r>=0?r-1:r+t/3)},parseUVIndex:function(e,t){var r=parseInt(e,10);return 2*(r>=0?r-1:r+t/2)},addVertex:function(e,t,r){var s=this.vertices,i=this.object.geometry.vertices;i.push(s[e+0],s[e+1],s[e+2]),i.push(s[t+0],s[t+1],s[t+2]),i.push(s[r+0],s[r+1],s[r+2])},addVertexPoint:function(e){var t=this.vertices;this.object.geometry.vertices.push(t[e+0],t[e+1],t[e+2])},addVertexLine:function(e){var t=this.vertices;this.object.geometry.vertices.push(t[e+0],t[e+1],t[e+2])},addNormal:function(e,t,r){var s=this.normals,i=this.object.geometry.normals;i.push(s[e+0],s[e+1],s[e+2]),i.push(s[t+0],s[t+1],s[t+2]),i.push(s[r+0],s[r+1],s[r+2])},addFaceNormal:function(e,t,r){var s=this.vertices,i=this.object.geometry.normals;vA.fromArray(s,e),vB.fromArray(s,t),vC.fromArray(s,r),cb.subVectors(vC,vB),ab.subVectors(vA,vB),cb.cross(ab),cb.normalize(),i.push(cb.x,cb.y,cb.z),i.push(cb.x,cb.y,cb.z),i.push(cb.x,cb.y,cb.z)},addColor:function(e,t,r){var s=this.colors,i=this.object.geometry.colors;void 0!==s[e]&&i.push(s[e+0],s[e+1],s[e+2]),void 0!==s[t]&&i.push(s[t+0],s[t+1],s[t+2]),void 0!==s[r]&&i.push(s[r+0],s[r+1],s[r+2])},addUV:function(e,t,r){var s=this.uvs,i=this.object.geometry.uvs;i.push(s[e+0],s[e+1]),i.push(s[t+0],s[t+1]),i.push(s[r+0],s[r+1])},addDefaultUV:function(){var e=this.object.geometry.uvs;e.push(0,0),e.push(0,0),e.push(0,0)},addUVLine:function(e){var t=this.uvs;this.object.geometry.uvs.push(t[e+0],t[e+1])},addFace:function(e,t,r,s,i,a,o,n,l){var h=this.vertices.length,c=this.parseVertexIndex(e,h),u=this.parseVertexIndex(t,h),p=this.parseVertexIndex(r,h);if(this.addVertex(c,u,p),this.addColor(c,u,p),void 0!==o&&""!==o){var m=this.normals.length;c=this.parseNormalIndex(o,m),u=this.parseNormalIndex(n,m),p=this.parseNormalIndex(l,m),this.addNormal(c,u,p),this.object.geometry.hasNormalIndices=!0}else this.addFaceNormal(c,u,p);if(void 0!==s&&""!==s){var d=this.uvs.length;c=this.parseUVIndex(s,d),u=this.parseUVIndex(i,d),p=this.parseUVIndex(a,d),this.addUV(c,u,p),this.object.geometry.hasUVIndices=!0}else this.addDefaultUV()},addPointGeometry:function(e){this.object.geometry.type="Points";for(var t=this.vertices.length,r=0,s=e.length;r<s;r++)this.addVertexPoint(this.parseVertexIndex(e[r],t))},addLineGeometry:function(e,t){this.object.geometry.type="Line";for(var r=this.vertices.length,s=this.uvs.length,i=0,a=e.length;i<a;i++)this.addVertexLine(this.parseVertexIndex(e[i],r));var o=0;for(a=t.length;o<a;o++)this.addUVLine(this.parseUVIndex(t[o],s))}};return e.startObject("",!1),e}function OBJLoader(e){THREE.Loader.call(this,e),this.materials=null}OBJLoader.prototype=Object.assign(Object.create(THREE.Loader.prototype),{constructor:OBJLoader,load:function(e,t,r,s){var i=this,a=new THREE.FileLoader(this.manager);a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(e,function(r){try{t(i.parse(r))}catch(t){s?s(t):console.error(t),i.manager.itemError(e)}},r,s)},setMaterials:function(e){return this.materials=e,this},parse:function(e){var t=new ParserState;-1!==e.indexOf("\r\n")&&(e=e.replace(/\r\n/g,"\n")),-1!==e.indexOf("\\\n")&&(e=e.replace(/\\\n/g,""));for(var r=e.split("\n"),s="",i="",a=[],o="function"==typeof"".trimLeft,n=0,l=r.length;n<l;n++)if(s=r[n],0!==(s=o?s.trimLeft():s.trim()).length&&"#"!==(i=s.charAt(0)))if("v"===i){var h=s.split(/\s+/);switch(h[0]){case"v":t.vertices.push(parseFloat(h[1]),parseFloat(h[2]),parseFloat(h[3])),h.length>=7?t.colors.push(parseFloat(h[4]),parseFloat(h[5]),parseFloat(h[6])):t.colors.push(void 0,void 0,void 0);break;case"vn":t.normals.push(parseFloat(h[1]),parseFloat(h[2]),parseFloat(h[3]));break;case"vt":t.uvs.push(parseFloat(h[1]),parseFloat(h[2]))}}else if("f"===i){for(var c=s.substr(1).trim().split(/\s+/),u=[],p=0,m=c.length;p<m;p++){var d=c[p];if(d.length>0){var f=d.split("/");u.push(f)}}var v=u[0];for(p=1,m=u.length-1;p<m;p++){var b=u[p],g=u[p+1];t.addFace(v[0],b[0],g[0],v[1],b[1],g[1],v[2],b[2],g[2])}}else if("l"===i){var E=s.substring(1).trim().split(" "),y=[],j=[];if(-1===s.indexOf("/"))y=E;else for(var x=0,H=E.length;x<H;x++){var R=E[x].split("/");""!==R[0]&&y.push(R[0]),""!==R[1]&&j.push(R[1])}t.addLineGeometry(y,j)}else if("p"===i){var T=s.substr(1).trim().split(" ");t.addPointGeometry(T)}else if(null!==(a=object_pattern.exec(s))){var V=(" "+a[0].substr(1).trim()).substr(1);t.startObject(V)}else if(material_use_pattern.test(s))t.object.startMaterial(s.substring(7).trim(),t.materialLibraries);else if(material_library_pattern.test(s))t.materialLibraries.push(s.substring(7).trim());else if(map_use_pattern.test(s))console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');else if("s"===i){if((a=s.split(" ")).length>1){var L=a[1].trim().toLowerCase();t.object.smooth="0"!==L&&"off"!==L}else t.object.smooth=!0;(S=t.object.currentMaterial())&&(S.smooth=t.object.smooth)}else{if("\0"===s)continue;console.warn('THREE.OBJLoader: Unexpected line: "'+s+'"')}t.finalize();var w=new THREE.Group;w.materialLibraries=[].concat(t.materialLibraries);for(n=0,l=t.objects.length;n<l;n++){var I=t.objects[n],_=I.geometry,M=I.materials,F="Line"===_.type,A="Points"===_.type,B=!1;if(0!==_.vertices.length){var z=new THREE.BufferGeometry;z.setAttribute("position",new THREE.Float32BufferAttribute(_.vertices,3)),!0===_.hasNormalIndices&&z.setAttribute("normal",new THREE.Float32BufferAttribute(_.normals,3)),_.colors.length>0&&(B=!0,z.setAttribute("color",new THREE.Float32BufferAttribute(_.colors,3))),!0===_.hasUVIndices&&z.setAttribute("uv",new THREE.Float32BufferAttribute(_.uvs,2));for(var C,P=[],U=0,O=M.length;U<O;U++){var N=(D=M[U]).name+"_"+D.smooth+"_"+B,S=t.materials[N];if(null!==this.materials)if(S=this.materials.create(D.name),!F||!S||S instanceof THREE.LineBasicMaterial){if(A&&S&&!(S instanceof THREE.PointsMaterial)){var G=new THREE.PointsMaterial({size:10,sizeAttenuation:!1});THREE.Material.prototype.copy.call(G,S),G.color.copy(S.color),G.map=S.map,S=G}}else{var J=new THREE.LineBasicMaterial;THREE.Material.prototype.copy.call(J,S),J.color.copy(S.color),S=J}void 0===S&&((S=F?new THREE.LineBasicMaterial:A?new THREE.PointsMaterial({size:1,sizeAttenuation:!1}):new THREE.MeshPhongMaterial).name=D.name,S.flatShading=!D.smooth,S.vertexColors=B,t.materials[N]=S),P.push(S)}if(P.length>1){for(U=0,O=M.length;U<O;U++){var D=M[U];z.addGroup(D.groupStart,D.groupCount,U)}C=F?new THREE.LineSegments(z,P):A?new THREE.Points(z,P):new THREE.Mesh(z,P)}else C=F?new THREE.LineSegments(z,P[0]):A?new THREE.Points(z,P[0]):new THREE.Mesh(z,P[0]);C.name=I.name,w.add(C)}}return w}});export default OBJLoader;